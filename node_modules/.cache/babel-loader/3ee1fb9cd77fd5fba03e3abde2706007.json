{"ast":null,"code":"import { getClosestItemIndexes, getLogger, head, isDefined, isNotDefined, last } from \"../utils\";\nconst log = getLogger(\"evaluator\");\n\nfunction getNewEnd(fallbackEnd, xAccessor, initialXScale, start) {\n  const {\n    lastItem,\n    lastItemX\n  } = fallbackEnd;\n  const lastItemXValue = xAccessor(lastItem);\n  const [rangeStart, rangeEnd] = initialXScale.range();\n  const newEnd = (rangeEnd - rangeStart) / (lastItemX - rangeStart) * (lastItemXValue - start) + start;\n  return newEnd;\n}\n\nfunction extentsWrapper(useWholeData, clamp, pointsPerPxThreshold, minPointsPerPxThreshold, flipXScale) {\n  function filterData(data, inputDomain, xAccessor, initialXScale, // @ts-ignore\n  {\n    currentPlotData,\n    currentDomain,\n    fallbackStart,\n    fallbackEnd\n  } = {}) {\n    if (useWholeData) {\n      return {\n        plotData: data,\n        domain: inputDomain\n      };\n    }\n\n    let left = head(inputDomain);\n    let right = last(inputDomain);\n    let clampedDomain = inputDomain;\n    let filteredData = getFilteredResponse(data, left, right, xAccessor);\n\n    if (filteredData.length === 1 && isDefined(fallbackStart)) {\n      left = fallbackStart;\n      right = getNewEnd(fallbackEnd, xAccessor, initialXScale, left);\n      clampedDomain = [left, right];\n      filteredData = getFilteredResponse(data, left, right, xAccessor);\n    }\n\n    if (typeof clamp === \"function\") {\n      clampedDomain = clamp(clampedDomain, [xAccessor(head(data)), xAccessor(last(data))]);\n    } else {\n      if (clamp === \"left\" || clamp === \"both\" || clamp === true) {\n        clampedDomain = [Math.max(left, xAccessor(head(data))), clampedDomain[1]];\n      }\n\n      if (clamp === \"right\" || clamp === \"both\" || clamp === true) {\n        clampedDomain = [clampedDomain[0], Math.min(right, xAccessor(last(data)))];\n      }\n    }\n\n    if (clampedDomain !== inputDomain) {\n      filteredData = getFilteredResponse(data, clampedDomain[0], clampedDomain[1], xAccessor);\n    }\n\n    const realInputDomain = clampedDomain;\n    const xScale = initialXScale.copy().domain(realInputDomain);\n    let width = Math.floor(xScale(xAccessor(last(filteredData))) - xScale(xAccessor(head(filteredData)))); // prevent negative width when flipXScale\n\n    if (flipXScale && width < 0) {\n      width = width * -1;\n    }\n\n    let plotData;\n    let domain;\n    const chartWidth = last(xScale.range()) - head(xScale.range()); // @ts-ignore\n\n    log(`Trying to show ${filteredData.length} points in ${width}px,` + ` I can show up to ${showMaxThreshold(width, pointsPerPxThreshold) - 1} points in that width. ` + `Also FYI the entire chart width is ${chartWidth}px and pointsPerPxThreshold is ${pointsPerPxThreshold}`);\n\n    if (canShowTheseManyPeriods(width, filteredData.length, pointsPerPxThreshold, minPointsPerPxThreshold)) {\n      plotData = filteredData;\n      domain = realInputDomain; // @ts-ignore\n\n      log(\"AND IT WORKED\");\n    } else {\n      if (chartWidth > showMaxThreshold(width, pointsPerPxThreshold) && isDefined(fallbackEnd)) {\n        plotData = filteredData;\n        const newEnd = getNewEnd(fallbackEnd, xAccessor, initialXScale, head(realInputDomain));\n        domain = [head(realInputDomain), newEnd];\n        const newXScale = xScale.copy().domain(domain);\n        const newWidth = Math.floor(newXScale(xAccessor(last(plotData))) - newXScale(xAccessor(head(plotData)))); // @ts-ignore\n\n        log(`and ouch, that is too much, so instead showing ${plotData.length} in ${newWidth}px`);\n      } else {\n        plotData = currentPlotData || filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));\n        domain = currentDomain || [xAccessor(head(plotData)), xAccessor(last(plotData))];\n        const newXScale = xScale.copy().domain(domain);\n        const newWidth = Math.floor(newXScale(xAccessor(last(plotData))) - newXScale(xAccessor(head(plotData)))); // @ts-ignore\n\n        log(`and ouch, that is too much, so instead showing ${plotData.length} in ${newWidth}px`);\n      }\n    }\n\n    return {\n      plotData,\n      domain\n    };\n  }\n\n  return {\n    filterData\n  };\n}\n\nfunction canShowTheseManyPeriods(width, arrayLength, maxThreshold, minThreshold) {\n  return arrayLength > showMinThreshold(width, minThreshold) && arrayLength < showMaxThreshold(width, maxThreshold);\n}\n\nfunction showMinThreshold(width, threshold) {\n  return Math.max(1, Math.ceil(width * threshold));\n}\n\nfunction showMaxThreshold(width, threshold) {\n  return Math.floor(width * threshold);\n}\n\nfunction showMax(width, threshold) {\n  return Math.floor(showMaxThreshold(width, threshold) * 0.97);\n}\n\nfunction getFilteredResponse(data, left, right, xAccessor) {\n  const newLeftIndex = getClosestItemIndexes(data, left, xAccessor).right;\n  const newRightIndex = getClosestItemIndexes(data, right, xAccessor).left;\n  const filteredData = data.slice(newLeftIndex, newRightIndex + 1);\n  return filteredData;\n}\n\nexport default function ({\n  xScale,\n  useWholeData,\n  clamp,\n  pointsPerPxThreshold,\n  minPointsPerPxThreshold,\n  flipXScale\n}) {\n  return extentsWrapper(useWholeData || isNotDefined(xScale.invert), clamp, pointsPerPxThreshold, minPointsPerPxThreshold, flipXScale);\n}","map":{"version":3,"sources":["../../src/scale/evaluator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { getClosestItemIndexes, getLogger, head, isDefined, isNotDefined, last, } from \"../utils\";\nconst log = getLogger(\"evaluator\");\nfunction getNewEnd(fallbackEnd, xAccessor, initialXScale, start) {\n    const { lastItem, lastItemX, } = fallbackEnd;\n    const lastItemXValue = xAccessor(lastItem);\n    const [rangeStart, rangeEnd] = initialXScale.range();\n    const newEnd = (rangeEnd - rangeStart) / (lastItemX - rangeStart) * (lastItemXValue - start) + start;\n    return newEnd;\n}\nfunction extentsWrapper(useWholeData, clamp, pointsPerPxThreshold, minPointsPerPxThreshold, flipXScale) {\n    function filterData(data, inputDomain, xAccessor, initialXScale, \n    // @ts-ignore\n    { currentPlotData, currentDomain, fallbackStart, fallbackEnd } = {}) {\n        if (useWholeData) {\n            return { plotData: data, domain: inputDomain };\n        }\n        let left = head(inputDomain);\n        let right = last(inputDomain);\n        let clampedDomain = inputDomain;\n        let filteredData = getFilteredResponse(data, left, right, xAccessor);\n        if (filteredData.length === 1 && isDefined(fallbackStart)) {\n            left = fallbackStart;\n            right = getNewEnd(fallbackEnd, xAccessor, initialXScale, left);\n            clampedDomain = [\n                left,\n                right,\n            ];\n            filteredData = getFilteredResponse(data, left, right, xAccessor);\n        }\n        if (typeof clamp === \"function\") {\n            clampedDomain = clamp(clampedDomain, [xAccessor(head(data)), xAccessor(last(data))]);\n        }\n        else {\n            if (clamp === \"left\" || clamp === \"both\" || clamp === true) {\n                clampedDomain = [\n                    Math.max(left, xAccessor(head(data))),\n                    clampedDomain[1],\n                ];\n            }\n            if (clamp === \"right\" || clamp === \"both\" || clamp === true) {\n                clampedDomain = [\n                    clampedDomain[0],\n                    Math.min(right, xAccessor(last(data))),\n                ];\n            }\n        }\n        if (clampedDomain !== inputDomain) {\n            filteredData = getFilteredResponse(data, clampedDomain[0], clampedDomain[1], xAccessor);\n        }\n        const realInputDomain = clampedDomain;\n        const xScale = initialXScale.copy().domain(realInputDomain);\n        let width = Math.floor(xScale(xAccessor(last(filteredData)))\n            - xScale(xAccessor(head(filteredData))));\n        // prevent negative width when flipXScale\n        if (flipXScale && width < 0) {\n            width = width * -1;\n        }\n        let plotData;\n        let domain;\n        const chartWidth = last(xScale.range()) - head(xScale.range());\n        // @ts-ignore\n        log(`Trying to show ${filteredData.length} points in ${width}px,`\n            + ` I can show up to ${showMaxThreshold(width, pointsPerPxThreshold) - 1} points in that width. `\n            + `Also FYI the entire chart width is ${chartWidth}px and pointsPerPxThreshold is ${pointsPerPxThreshold}`);\n        if (canShowTheseManyPeriods(width, filteredData.length, pointsPerPxThreshold, minPointsPerPxThreshold)) {\n            plotData = filteredData;\n            domain = realInputDomain;\n            // @ts-ignore\n            log(\"AND IT WORKED\");\n        }\n        else {\n            if (chartWidth > showMaxThreshold(width, pointsPerPxThreshold) && isDefined(fallbackEnd)) {\n                plotData = filteredData;\n                const newEnd = getNewEnd(fallbackEnd, xAccessor, initialXScale, head(realInputDomain));\n                domain = [\n                    head(realInputDomain),\n                    newEnd,\n                ];\n                const newXScale = xScale.copy().domain(domain);\n                const newWidth = Math.floor(newXScale(xAccessor(last(plotData)))\n                    - newXScale(xAccessor(head(plotData))));\n                // @ts-ignore\n                log(`and ouch, that is too much, so instead showing ${plotData.length} in ${newWidth}px`);\n            }\n            else {\n                plotData = currentPlotData || filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));\n                domain = currentDomain || [xAccessor(head(plotData)), xAccessor(last(plotData))];\n                const newXScale = xScale.copy().domain(domain);\n                const newWidth = Math.floor(newXScale(xAccessor(last(plotData)))\n                    - newXScale(xAccessor(head(plotData))));\n                // @ts-ignore\n                log(`and ouch, that is too much, so instead showing ${plotData.length} in ${newWidth}px`);\n            }\n        }\n        return { plotData, domain };\n    }\n    return { filterData };\n}\nfunction canShowTheseManyPeriods(width, arrayLength, maxThreshold, minThreshold) {\n    return arrayLength > showMinThreshold(width, minThreshold) && arrayLength < showMaxThreshold(width, maxThreshold);\n}\nfunction showMinThreshold(width, threshold) {\n    return Math.max(1, Math.ceil(width * threshold));\n}\nfunction showMaxThreshold(width, threshold) {\n    return Math.floor(width * threshold);\n}\nfunction showMax(width, threshold) {\n    return Math.floor(showMaxThreshold(width, threshold) * 0.97);\n}\nfunction getFilteredResponse(data, left, right, xAccessor) {\n    const newLeftIndex = getClosestItemIndexes(data, left, xAccessor).right;\n    const newRightIndex = getClosestItemIndexes(data, right, xAccessor).left;\n    const filteredData = data.slice(newLeftIndex, newRightIndex + 1);\n    return filteredData;\n}\nexport default function ({ xScale, useWholeData, clamp, pointsPerPxThreshold, minPointsPerPxThreshold, flipXScale, }) {\n    return extentsWrapper(useWholeData || isNotDefined(xScale.invert), clamp, pointsPerPxThreshold, minPointsPerPxThreshold, flipXScale);\n}\n//# sourceMappingURL=evaluator.js.map"]},"metadata":{},"sourceType":"module"}