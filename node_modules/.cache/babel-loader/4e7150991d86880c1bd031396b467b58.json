{"ast":null,"code":"/* an extension to d3.zip so we call a function instead of an array */\nimport { min } from \"d3-array\";\nimport identity from \"./identity\";\nexport default function zipper() {\n  let combine = identity;\n\n  function zip() {\n    const n = arguments.length;\n\n    if (!n) {\n      return [];\n    }\n\n    const m = min(arguments, d3_zipLength);\n    let i;\n    const zips = new Array(m);\n\n    for (i = -1; ++i < m;) {\n      // tslint:disable-next-line: no-shadowed-variable\n      for (let j = -1, zip = zips[i] = new Array(n); ++j < n;) {\n        zip[j] = arguments[j][i];\n      } // @ts-ignore\n\n\n      zips[i] = combine.apply(this, zips[i]);\n    }\n\n    return zips;\n  }\n\n  function d3_zipLength(d) {\n    return d.length;\n  }\n\n  zip.combine = function (x) {\n    if (!arguments.length) {\n      return combine;\n    }\n\n    combine = x;\n    return zip;\n  };\n\n  return zip;\n}","map":{"version":3,"sources":["../../src/utils/zipper.ts"],"names":[],"mappings":"AAAA;AAEA,SAAS,GAAT,QAAoB,UAApB;AAEA,OAAO,QAAP,MAAqB,YAArB;AAEA,eAAc,SAAU,MAAV,GAAgB;AAC1B,MAAI,OAAO,GAAG,QAAd;;AAEA,WAAS,GAAT,GAAY;AACR,UAAM,CAAC,GAAG,SAAS,CAAC,MAApB;;AACA,QAAI,CAAC,CAAL,EAAQ;AAAE,aAAO,EAAP;AAAY;;AACtB,UAAM,CAAC,GAAG,GAAG,CAAC,SAAD,EAAY,YAAZ,CAAb;AAEA,QAAI,CAAJ;AACA,UAAM,IAAI,GAAG,IAAI,KAAJ,CAAU,CAAV,CAAb;;AACA,SAAK,CAAC,GAAG,CAAC,CAAV,EAAa,EAAE,CAAF,GAAM,CAAnB,GAAuB;AACnB;AACA,WAAK,IAAI,CAAC,GAAG,CAAC,CAAT,EAAY,GAAG,GAAG,IAAI,CAAC,CAAD,CAAJ,GAAU,IAAI,KAAJ,CAAU,CAAV,CAAjC,EAA+C,EAAE,CAAF,GAAM,CAArD,GAAyD;AACrD,QAAA,GAAG,CAAC,CAAD,CAAH,GAAS,SAAS,CAAC,CAAD,CAAT,CAAa,CAAb,CAAT;AACH,OAJkB,CAMnB;;;AACA,MAAA,IAAI,CAAC,CAAD,CAAJ,GAAU,OAAO,CAAC,KAAR,CAAc,IAAd,EAAoB,IAAI,CAAC,CAAD,CAAxB,CAAV;AACH;;AACD,WAAO,IAAP;AACH;;AACD,WAAS,YAAT,CAAsB,CAAtB,EAAuB;AACnB,WAAO,CAAC,CAAC,MAAT;AACH;;AACD,EAAA,GAAG,CAAC,OAAJ,GAAc,UAAU,CAAV,EAAW;AACrB,QAAI,CAAC,SAAS,CAAC,MAAf,EAAuB;AACnB,aAAO,OAAP;AACH;;AACD,IAAA,OAAO,GAAG,CAAV;AACA,WAAO,GAAP;AACH,GAND;;AAOA,SAAO,GAAP;AACH","sourceRoot":"","sourcesContent":["/* an extension to d3.zip so we call a function instead of an array */\nimport { min } from \"d3-array\";\nimport identity from \"./identity\";\nexport default function zipper() {\n    let combine = identity;\n    function zip() {\n        const n = arguments.length;\n        if (!n) {\n            return [];\n        }\n        const m = min(arguments, d3_zipLength);\n        let i;\n        const zips = new Array(m);\n        for (i = -1; ++i < m;) {\n            // tslint:disable-next-line: no-shadowed-variable\n            for (let j = -1, zip = zips[i] = new Array(n); ++j < n;) {\n                zip[j] = arguments[j][i];\n            }\n            // @ts-ignore\n            zips[i] = combine.apply(this, zips[i]);\n        }\n        return zips;\n    }\n    function d3_zipLength(d) {\n        return d.length;\n    }\n    zip.combine = function (x) {\n        if (!arguments.length) {\n            return combine;\n        }\n        combine = x;\n        return zip;\n    };\n    return zip;\n}\n//# sourceMappingURL=zipper.js.map"]},"metadata":{},"sourceType":"module"}