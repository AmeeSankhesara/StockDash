{"ast":null,"code":"import { head } from \".\";\n/**\n * Bar width is based on the amount of items in the plot data and the distance between the first and last of those\n * items.\n * @param props the props passed to the series.\n * @param moreProps an object holding the xScale, xAccessor and plotData.\n * @return {number} the bar width.\n */\n\nexport const plotDataLengthBarWidth = (props, moreProps) => {\n  const {\n    widthRatio\n  } = props;\n  const {\n    xScale\n  } = moreProps;\n  const [l, r] = xScale.range();\n  const totalWidth = Math.abs(r - l);\n\n  if (xScale.invert != null) {\n    const [dl, dr] = xScale.domain();\n    const width = totalWidth / Math.abs(dl - dr);\n    return width * widthRatio;\n  } else {\n    const width = totalWidth / xScale.domain().length;\n    return width * widthRatio;\n  }\n};\n/**\n * Generates a width function that calculates the bar width based on the given time interval.\n * @param interval a d3-time time interval.\n * @return {Function} the width function.\n */\n\nexport const timeIntervalBarWidth = interval => {\n  return function (props, moreProps) {\n    const {\n      widthRatio\n    } = props;\n    const {\n      xScale,\n      xAccessor,\n      plotData\n    } = moreProps;\n    const first = xAccessor(head(plotData));\n    return Math.abs(xScale(interval.offset(first, 1)) - xScale(first)) * widthRatio;\n  };\n};","map":{"version":3,"sources":["../../src/utils/barWidth.ts"],"names":[],"mappings":"AAAA,SAAS,IAAT,QAAqB,GAArB;AAEA;;;;;;;;AAOA,OAAO,MAAM,sBAAsB,GAAG,CAAC,KAAD,EAAgC,SAAhC,KAAuE;AACzG,QAAM;AAAE,IAAA;AAAF,MAAiB,KAAvB;AACA,QAAM;AAAE,IAAA;AAAF,MAAa,SAAnB;AAEA,QAAM,CAAC,CAAD,EAAI,CAAJ,IAAS,MAAM,CAAC,KAAP,EAAf;AAEA,QAAM,UAAU,GAAG,IAAI,CAAC,GAAL,CAAS,CAAC,GAAG,CAAb,CAAnB;;AACA,MAAI,MAAM,CAAC,MAAP,IAAiB,IAArB,EAA2B;AACvB,UAAM,CAAC,EAAD,EAAK,EAAL,IAAW,MAAM,CAAC,MAAP,EAAjB;AACA,UAAM,KAAK,GAAG,UAAU,GAAG,IAAI,CAAC,GAAL,CAAS,EAAE,GAAG,EAAd,CAA3B;AACA,WAAO,KAAK,GAAG,UAAf;AACH,GAJD,MAIO;AACH,UAAM,KAAK,GAAG,UAAU,GAAG,MAAM,CAAC,MAAP,GAAgB,MAA3C;AACA,WAAO,KAAK,GAAG,UAAf;AACH;AACJ,CAfM;AAiBP;;;;;;AAKA,OAAO,MAAM,oBAAoB,GAAI,QAAD,IAAa;AAC7C,SAAO,UAAU,KAAV,EAAyC,SAAzC,EAAkG;AACrG,UAAM;AAAE,MAAA;AAAF,QAAiB,KAAvB;AACA,UAAM;AAAE,MAAA,MAAF;AAAU,MAAA,SAAV;AAAqB,MAAA;AAArB,QAAkC,SAAxC;AAEA,UAAM,KAAK,GAAG,SAAS,CAAC,IAAI,CAAC,QAAD,CAAL,CAAvB;AACA,WAAO,IAAI,CAAC,GAAL,CAAS,MAAM,CAAC,QAAQ,CAAC,MAAT,CAAgB,KAAhB,EAAuB,CAAvB,CAAD,CAAN,GAAoC,MAAM,CAAC,KAAD,CAAnD,IAA8D,UAArE;AACH,GAND;AAOH,CARM","sourceRoot":"","sourcesContent":["import { head } from \".\";\n/**\n * Bar width is based on the amount of items in the plot data and the distance between the first and last of those\n * items.\n * @param props the props passed to the series.\n * @param moreProps an object holding the xScale, xAccessor and plotData.\n * @return {number} the bar width.\n */\nexport const plotDataLengthBarWidth = (props, moreProps) => {\n    const { widthRatio } = props;\n    const { xScale } = moreProps;\n    const [l, r] = xScale.range();\n    const totalWidth = Math.abs(r - l);\n    if (xScale.invert != null) {\n        const [dl, dr] = xScale.domain();\n        const width = totalWidth / Math.abs(dl - dr);\n        return width * widthRatio;\n    }\n    else {\n        const width = totalWidth / xScale.domain().length;\n        return width * widthRatio;\n    }\n};\n/**\n * Generates a width function that calculates the bar width based on the given time interval.\n * @param interval a d3-time time interval.\n * @return {Function} the width function.\n */\nexport const timeIntervalBarWidth = (interval) => {\n    return function (props, moreProps) {\n        const { widthRatio } = props;\n        const { xScale, xAccessor, plotData } = moreProps;\n        const first = xAccessor(head(plotData));\n        return Math.abs(xScale(interval.offset(first, 1)) - xScale(first)) * widthRatio;\n    };\n};\n//# sourceMappingURL=barWidth.js.map"]},"metadata":{},"sourceType":"module"}