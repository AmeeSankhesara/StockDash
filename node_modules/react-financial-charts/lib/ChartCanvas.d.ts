import * as PropTypes from "prop-types";
import * as React from "react";
import { mouseBasedZoomAnchor } from "./utils/zoomBehavior";
interface ChartCanvasProps {
    readonly width: number;
    readonly height: number;
    readonly margin?: {
        bottom: number;
        left: number;
        right: number;
        top: number;
    };
    readonly ratio: number;
    readonly type?: "svg" | "hybrid";
    readonly pointsPerPxThreshold?: number;
    readonly minPointsPerPxThreshold?: number;
    readonly data: any[];
    readonly xAccessor?: any;
    readonly xExtents?: any[] | any;
    readonly zoomAnchor?: any;
    readonly className?: string;
    readonly seriesName: string;
    readonly zIndex?: number;
    readonly xScale: any;
    readonly postCalculator?: any;
    readonly flipXScale?: boolean;
    readonly useCrossHairStyleCursor?: boolean;
    readonly padding?: number | {
        bottom: number;
        left: number;
        right: number;
        top: number;
    };
    readonly defaultFocus?: boolean;
    readonly zoomMultiplier?: number;
    readonly onLoadMore?: any;
    readonly displayXAccessor: any;
    readonly mouseMoveEvent?: boolean;
    readonly panEvent?: boolean;
    readonly clamp?: string | boolean | any;
    readonly zoomEvent?: boolean;
    readonly onSelect?: any;
    readonly maintainPointsPerPixelOnResize?: boolean;
    readonly disableInteraction?: boolean;
}
interface ChartCanvasState {
    xAccessor?: any;
    displayXAccessor?: any;
    filterData?: any;
    chartConfig?: any;
    plotData?: any;
    xScale?: any;
}
export declare class ChartCanvas extends React.Component<ChartCanvasProps, ChartCanvasState> {
    static defaultProps: {
        margin: {
            top: number;
            right: number;
            bottom: number;
            left: number;
        };
        type: string;
        pointsPerPxThreshold: number;
        minPointsPerPxThreshold: number;
        className: string;
        zIndex: number;
        xExtents: any[];
        postCalculator: (d: any) => any;
        padding: number;
        xAccessor: (d: any) => any;
        flipXScale: boolean;
        useCrossHairStyleCursor: boolean;
        defaultFocus: boolean;
        onLoadMore: () => void;
        onSelect: () => void;
        mouseMoveEvent: boolean;
        panEvent: boolean;
        zoomEvent: boolean;
        zoomMultiplier: number;
        clamp: boolean;
        zoomAnchor: typeof mouseBasedZoomAnchor;
        maintainPointsPerPixelOnResize: boolean;
        disableInteraction: boolean;
    };
    static childContextTypes: {
        plotData: PropTypes.Requireable<any[]>;
        fullData: PropTypes.Requireable<any[]>;
        chartConfig: PropTypes.Validator<(PropTypes.InferProps<{
            id: PropTypes.Validator<string | number>;
            origin: PropTypes.Validator<(number | null | undefined)[]>;
            padding: PropTypes.Requireable<number | PropTypes.InferProps<{
                top: PropTypes.Requireable<number>;
                bottom: PropTypes.Requireable<number>;
            }>>;
            yExtents: PropTypes.Requireable<(((...args: any[]) => any) | null | undefined)[]>;
            yExtentsProvider: PropTypes.Requireable<(...args: any[]) => any>;
            yScale: PropTypes.Validator<(...args: any[]) => any>;
            mouseCoordinates: PropTypes.Requireable<PropTypes.InferProps<{
                at: PropTypes.Requireable<string>;
                format: PropTypes.Requireable<(...args: any[]) => any>;
            }>>;
            width: PropTypes.Validator<number>;
            height: PropTypes.Validator<number>;
        }> | null | undefined)[]>;
        xScale: PropTypes.Validator<(...args: any[]) => any>;
        xAccessor: PropTypes.Validator<(...args: any[]) => any>;
        displayXAccessor: PropTypes.Validator<(...args: any[]) => any>;
        width: PropTypes.Validator<number>;
        height: PropTypes.Validator<number>;
        chartCanvasType: PropTypes.Validator<string>;
        margin: PropTypes.Validator<object>;
        ratio: PropTypes.Validator<number>;
        getCanvasContexts: PropTypes.Requireable<(...args: any[]) => any>;
        xAxisZoom: PropTypes.Requireable<(...args: any[]) => any>;
        yAxisZoom: PropTypes.Requireable<(...args: any[]) => any>;
        amIOnTop: PropTypes.Requireable<(...args: any[]) => any>;
        redraw: PropTypes.Requireable<(...args: any[]) => any>;
        subscribe: PropTypes.Requireable<(...args: any[]) => any>;
        unsubscribe: PropTypes.Requireable<(...args: any[]) => any>;
        setCursorClass: PropTypes.Requireable<(...args: any[]) => any>;
        generateSubscriptionId: PropTypes.Requireable<(...args: any[]) => any>;
        getMutableState: PropTypes.Requireable<(...args: any[]) => any>;
    };
    static ohlcv: (d: any) => {
        date: any;
        open: any;
        high: any;
        low: any;
        close: any;
        volume: any;
    };
    private canvasContainerNode;
    private eventCaptureNode;
    private finalPinch?;
    private fullData;
    private lastSubscriptionId;
    private mutableState;
    private panInProgress;
    private prevMouseXY;
    private subscriptions;
    private waitingForPinchZoomAnimationFrame?;
    private waitingForPanAnimationFrame?;
    private waitingForMouseMoveAnimationFrame?;
    private hackyWayToStopPanBeyondBounds__plotData;
    private hackyWayToStopPanBeyondBounds__domain;
    constructor(props: ChartCanvasProps);
    saveEventCaptureNode(node: any): void;
    saveCanvasContainerNode(node: any): void;
    getMutableState(): any;
    getDataInfo(): {
        fullData: any;
        xAccessor?: any;
        displayXAccessor?: any;
        filterData?: any;
        chartConfig?: any;
        plotData?: any;
        xScale?: any;
    };
    getCanvasContexts(): any;
    generateSubscriptionId(): any;
    clearBothCanvas(): void;
    clearMouseCanvas(): void;
    clearThreeCanvas(): void;
    subscribe(id: any, rest: any): void;
    unsubscribe(id: any): void;
    getAllPanConditions(): any;
    setCursorClass(className: any): void;
    amIOnTop(id: any): boolean;
    handleContextMenu(mouseXY: any, e: any): void;
    calculateStateForDomain(newDomain: any): {
        xScale: any;
        plotData: any;
        chartConfig: any;
    };
    pinchZoomHelper(initialPinch: any, finalPinch: any): {
        chartConfig: any;
        xScale: any;
        plotData: any;
        mouseXY: any;
        currentItem: any;
    };
    cancelDrag(): void;
    handlePinchZoom(initialPinch: any, finalPinch: any, e: any): void;
    handlePinchZoomEnd(initialPinch: any, e: any): void;
    handleZoom(zoomDirection: any, mouseXY: any, e: any): void;
    xAxisZoom(newDomain: any): void;
    yAxisZoom(chartId: any, newDomain: any): void;
    triggerEvent(type: any, props?: any, e?: any): void;
    draw(props: any): void;
    redraw(): void;
    panHelper(mouseXY: any, initialXScale: any, { dx, dy }: {
        dx: any;
        dy: any;
    }, chartsToPan: any): {
        xScale: any;
        plotData: any;
        chartConfig: any;
        mouseXY: any;
        currentCharts: any;
        currentItem: any;
    };
    handlePan(mousePosition: any, panStartXScale: any, dxdy: any, chartsToPan: any, e: any): void;
    handlePanEnd(mousePosition: any, panStartXScale: any, dxdy: any, chartsToPan: any, e: any): void;
    handleMouseDown(mousePosition: any, currentCharts: any, e: any): void;
    handleMouseEnter(e: any): void;
    handleMouseMove(mouseXY: any, inputType: any, e: any): void;
    handleMouseLeave(e: any): void;
    handleDragStart({ startPos }: {
        startPos: any;
    }, e: any): void;
    handleDrag({ startPos, mouseXY }: {
        startPos: any;
        mouseXY: any;
    }, e: any): void;
    handleDragEnd({ mouseXY }: {
        mouseXY: any;
    }, e: any): void;
    handleClick(mousePosition: any, e: any): void;
    handleDoubleClick(mousePosition: any, e: any): void;
    getChildContext(): {
        fullData: any;
        plotData: any;
        width: number;
        height: number;
        chartConfig: any;
        xScale: any;
        xAccessor: any;
        displayXAccessor: any;
        chartCanvasType: "svg" | "hybrid" | undefined;
        margin: {
            bottom: number;
            left: number;
            right: number;
            top: number;
        } | undefined;
        ratio: number;
        xAxisZoom: (newDomain: any) => void;
        yAxisZoom: (chartId: any, newDomain: any) => void;
        getCanvasContexts: () => any;
        redraw: () => void;
        subscribe: (id: any, rest: any) => void;
        unsubscribe: (id: any) => void;
        generateSubscriptionId: () => any;
        getMutableState: () => any;
        amIOnTop: (id: any) => boolean;
        setCursorClass: (className: any) => void;
    };
    UNSAFE_componentWillReceiveProps(nextProps: any): void;
    resetYDomain(chartId: any): void;
    shouldComponentUpdate(): boolean;
    render(): JSX.Element;
}
export {};
